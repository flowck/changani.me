{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/firminocustomtheme/source/css/main.sass","path":"css/main.sass","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/concurrent.gif","path":"blog-images/concurrent.gif","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/non-concurrent.gif","path":"blog-images/non-concurrent.gif","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/urlfy.xyz.png","path":"blog-images/urlfy.xyz.png","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/Executing-concurrent-HTTP-requests.png","path":"blog-images/Executing-concurrent-HTTP-requests.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/firminocustomtheme/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1577806895866},{"_id":"themes/firminocustomtheme/README.md","hash":"4cd14dd17c22ce6ae75287ae30050d062a48e836","modified":1577806895867},{"_id":"themes/firminocustomtheme/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1577806895868},{"_id":"themes/firminocustomtheme/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1577806895872},{"_id":"source/_posts/Bulding-URLFY-The-idea.md","hash":"7cea352200734dcce15e2f1647f76d05918163c3","modified":1577969324595},{"_id":"source/_posts/Executing-concurrent-HTTP-requests.md","hash":"d8b3488aa72aced7dc72291360f007cd5f84a48d","modified":1577808477045},{"_id":"themes/firminocustomtheme/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1577806895868},{"_id":"themes/firminocustomtheme/languages/pt.yml","hash":"10ac1e67cd67db2f2ba8caf82fdd5e1042bac037","modified":1577806895869},{"_id":"themes/firminocustomtheme/layout/index.pug","hash":"4cfbc087cb54a1b2eebd076a06f0fe3c0348d77b","modified":1577806895871},{"_id":"themes/firminocustomtheme/layout/post.pug","hash":"f3cc4dede1f0944d3309871d446bf1a21434bbb8","modified":1577808457651},{"_id":"themes/firminocustomtheme/layout/_partial/_disqus.pug","hash":"b1f4cbff6e02fdf580da316cd2ac3fd24fdee659","modified":1577806895870},{"_id":"themes/firminocustomtheme/layout/_partial/_footer.pug","hash":"2a3c7049c14e5024248495e5e54f09c0370586d4","modified":1577806895870},{"_id":"themes/firminocustomtheme/layout/_partial/_header.pug","hash":"993f46a8302c2594e7f06d34ff6822be99ee177d","modified":1577806895871},{"_id":"themes/firminocustomtheme/source/css/main.sass","hash":"45c63c2aec97b65b72b69bf855ecfbe175a906d7","modified":1577806895877},{"_id":"themes/firminocustomtheme/source/js/script.js","hash":"93e40b0c061b73399a380c97a777c0d5f09a993f","modified":1577806895878},{"_id":"themes/firminocustomtheme/source/blog-images/concurrent.gif","hash":"e3858c8db8c29eb9ac35a535a9f3230cc29d95ac","modified":1577806895873},{"_id":"themes/firminocustomtheme/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577806895874},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577806895874},{"_id":"themes/firminocustomtheme/source/css/partials/_variables.sass","hash":"102baf696dedf3327eb0ea0ca980a3f0e79c482c","modified":1577806895877},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577806895876},{"_id":"themes/firminocustomtheme/source/blog-images/non-concurrent.gif","hash":"2eaabdc42285d206316253a093efcf9afb0ce3dc","modified":1577806895873},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577806895875},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1577806895875},{"_id":"themes/firminocustomtheme/source/blog-images/urlfy.xyz.png","hash":"24195ec06229d3d9bc3a0ec3739e55dda7bbc03a","modified":1577969153302},{"_id":"themes/firminocustomtheme/source/blog-images/Executing-concurrent-HTTP-requests.png","hash":"aa9bd5c790d567d9ccd9fe07f9c624c463246ee7","modified":1577808394817},{"_id":"public/2020/01/02/Bulding-URLFY-The-idea/index.html","hash":"38bd0fcc5367644da948d18cd4321d09af10a77d","modified":1577969362085},{"_id":"public/2019/12/22/Executing-concurrent-HTTP-requests/index.html","hash":"bb5f2479ebf3de3c58eeae0632012bac4781ec26","modified":1577969362085},{"_id":"public/archives/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/archives/2019/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/archives/2019/12/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/archives/2020/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/archives/2020/01/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/tags/urlfy-shortening-idea-projects/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/tags/javascript-nodejs-asynchronous-programming-promises-concurrency/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/index.html","hash":"d95f73c66ff210c7556059e675a018464494f15e","modified":1577969362085},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577969362085},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577969362085},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577969362085},{"_id":"public/blog-images/concurrent.gif","hash":"e3858c8db8c29eb9ac35a535a9f3230cc29d95ac","modified":1577969362085},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577969362085},{"_id":"public/js/script.js","hash":"93e40b0c061b73399a380c97a777c0d5f09a993f","modified":1577969362085},{"_id":"public/css/main.css","hash":"bd486d718c8f2a90aa86d7f8d482e3996577e81e","modified":1577969362085},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1577969362085},{"_id":"public/blog-images/non-concurrent.gif","hash":"2eaabdc42285d206316253a093efcf9afb0ce3dc","modified":1577969362085},{"_id":"public/blog-images/urlfy.xyz.png","hash":"24195ec06229d3d9bc3a0ec3739e55dda7bbc03a","modified":1577969362085},{"_id":"public/blog-images/Executing-concurrent-HTTP-requests.png","hash":"aa9bd5c790d567d9ccd9fe07f9c624c463246ee7","modified":1577969362085}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Bulding URLFY - The idea","date":"2020-01-02T12:21:08.000Z","description":"On this blog post I explain how I came out with the idea of building a shortening service","cover":"blog-images/urlfy.xyz.png","_content":"\nI was studying system design during the Christmas holidays of 2019, and while reading a blog [post](https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444), I found a challenge that quickly caught my attention: \n\n>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?\n\nThat sounded like a very simple web application, but then, in the same blog post, a few questions where also made:\n\n>How to generate a unique ID for each URL?\n>How would you generate unique IDs at scale (thousands of URL shortening >requests coming every second)?\n>How would your service handle redirects?\n>How would you support custom short URLs?\n>How to delete expired URLs etc?\n>How to track click stats?\n\nAfter reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.\n\nLong story short, I ended building something which a call [Ulrfy.xyz](https://app.urlfy.xyz), a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello [board](https://trello.com/b/YZDrArI2/urlfyxyz) where I manage my backlog is open for the public.\n\nThis was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.","source":"_posts/Bulding-URLFY-The-idea.md","raw":"---\ntitle: Bulding URLFY - The idea\ndate: 2020-01-02 12:21:08\ntags: urlfy, shortening, idea, projects\ndescription: On this blog post I explain how I came out with the idea of building a shortening service\ncover: \"blog-images/urlfy.xyz.png\"\n---\n\nI was studying system design during the Christmas holidays of 2019, and while reading a blog [post](https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444), I found a challenge that quickly caught my attention: \n\n>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?\n\nThat sounded like a very simple web application, but then, in the same blog post, a few questions where also made:\n\n>How to generate a unique ID for each URL?\n>How would you generate unique IDs at scale (thousands of URL shortening >requests coming every second)?\n>How would your service handle redirects?\n>How would you support custom short URLs?\n>How to delete expired URLs etc?\n>How to track click stats?\n\nAfter reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.\n\nLong story short, I ended building something which a call [Ulrfy.xyz](https://app.urlfy.xyz), a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello [board](https://trello.com/b/YZDrArI2/urlfyxyz) where I manage my backlog is open for the public.\n\nThis was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.","slug":"Bulding-URLFY-The-idea","published":1,"updated":"2020-01-02T12:48:44.595Z","_id":"ck4wq4cbp0000d5121lc81gvp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>I was studying system design during the Christmas holidays of 2019, and while reading a blog <a href=\"https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444\" target=\"_blank\" rel=\"noopener\">post</a>, I found a challenge that quickly caught my attention: </p>\n<blockquote>\n<p>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?</p>\n</blockquote>\n<p>That sounded like a very simple web application, but then, in the same blog post, a few questions where also made:</p>\n<blockquote>\n<p>How to generate a unique ID for each URL?<br>How would you generate unique IDs at scale (thousands of URL shortening &gt;requests coming every second)?<br>How would your service handle redirects?<br>How would you support custom short URLs?<br>How to delete expired URLs etc?<br>How to track click stats?</p>\n</blockquote>\n<p>After reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.</p>\n<p>Long story short, I ended building something which a call <a href=\"https://app.urlfy.xyz\" target=\"_blank\" rel=\"noopener\">Ulrfy.xyz</a>, a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello <a href=\"https://trello.com/b/YZDrArI2/urlfyxyz\" target=\"_blank\" rel=\"noopener\">board</a> where I manage my backlog is open for the public.</p>\n<p>This was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>I was studying system design during the Christmas holidays of 2019, and while reading a blog <a href=\"https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444\" target=\"_blank\" rel=\"noopener\">post</a>, I found a challenge that quickly caught my attention: </p>\n<blockquote>\n<p>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?</p>\n</blockquote>\n<p>That sounded like a very simple web application, but then, in the same blog post, a few questions where also made:</p>\n<blockquote>\n<p>How to generate a unique ID for each URL?<br>How would you generate unique IDs at scale (thousands of URL shortening &gt;requests coming every second)?<br>How would your service handle redirects?<br>How would you support custom short URLs?<br>How to delete expired URLs etc?<br>How to track click stats?</p>\n</blockquote>\n<p>After reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.</p>\n<p>Long story short, I ended building something which a call <a href=\"https://app.urlfy.xyz\" target=\"_blank\" rel=\"noopener\">Ulrfy.xyz</a>, a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello <a href=\"https://trello.com/b/YZDrArI2/urlfyxyz\" target=\"_blank\" rel=\"noopener\">board</a> where I manage my backlog is open for the public.</p>\n<p>This was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.</p>\n"},{"title":"Executing concurrent HTTP requests","date":"2019-12-22T21:09:57.000Z","description":"Read more about executing concurrent HTTP requests using Promises and async/await.","cover":"blog-images/Executing-concurrent-HTTP-requests.png","_content":"\nWhat is concurrency anyway? You've probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:\n\n>In [computer science](https://en.wikipedia.org/wiki/Computer_science), **concurrency** is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.\n\n\nWith this in mind, let's go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.\n\n## Helper function\n\nIn the script below, I implement a small helper function that uses [axios](https://www.npmjs.com/package/axios) to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.\n\n\n\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n## Non-concurrent requests\n\nIn the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. \n\nThe get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the [hrtime()](https://nodejs.org/api/process.html#process_process_hrtime_time) method from the process package.\n\n\n\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\nDue to the get function being called straight with the [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.\n\n\n\n![Non concurrent](/blog/blog-images/non-concurrent.gif)\n\n\n\n## Concurrent requests\n\nSince none of the results depend on each other, we can simply execute all the requests at once. \n\nWith just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request's execution time from 10s to 3s.\n\nIn the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. \n\n\n\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\nIn the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.\n\n\n\n![Concurrent requests](/blog/blog-images/concurrent.gif)\n\n\n\nThe Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.\n\n \n\n## References\n\n* [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n* [Concurrency vs. Parallelism, Lokesh Gupta](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/)\n* [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)","source":"_posts/Executing-concurrent-HTTP-requests.md","raw":"---\ntitle: Executing concurrent HTTP requests\ndate: 2019-12-22 21:09:57\ntags: javascript, nodejs, asynchronous, programming, promises, concurrency\ndescription: Read more about executing concurrent HTTP requests using Promises and async/await.\ncover: \"blog-images/Executing-concurrent-HTTP-requests.png\"\n---\n\nWhat is concurrency anyway? You've probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:\n\n>In [computer science](https://en.wikipedia.org/wiki/Computer_science), **concurrency** is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.\n\n\nWith this in mind, let's go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.\n\n## Helper function\n\nIn the script below, I implement a small helper function that uses [axios](https://www.npmjs.com/package/axios) to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.\n\n\n\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n## Non-concurrent requests\n\nIn the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. \n\nThe get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the [hrtime()](https://nodejs.org/api/process.html#process_process_hrtime_time) method from the process package.\n\n\n\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\nDue to the get function being called straight with the [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.\n\n\n\n![Non concurrent](/blog/blog-images/non-concurrent.gif)\n\n\n\n## Concurrent requests\n\nSince none of the results depend on each other, we can simply execute all the requests at once. \n\nWith just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request's execution time from 10s to 3s.\n\nIn the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. \n\n\n\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\nIn the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.\n\n\n\n![Concurrent requests](/blog/blog-images/concurrent.gif)\n\n\n\nThe Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.\n\n \n\n## References\n\n* [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n* [Concurrency vs. Parallelism, Lokesh Gupta](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/)\n* [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)","slug":"Executing-concurrent-HTTP-requests","published":1,"updated":"2019-12-31T16:07:57.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wq4cbv0001d512djh065pu","content":"<p>What is concurrency anyway? You’ve probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Computer_science\" target=\"_blank\" rel=\"noopener\">computer science</a>, <strong>concurrency</strong> is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.</p>\n</blockquote>\n<p>With this in mind, let’s go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.</p>\n<h2 id=\"Helper-function\"><a href=\"#Helper-function\" class=\"headerlink\" title=\"Helper function\"></a>Helper function</h2><p>In the script below, I implement a small helper function that uses <a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios</a> to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.</p>\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n<h2 id=\"Non-concurrent-requests\"><a href=\"#Non-concurrent-requests\" class=\"headerlink\" title=\"Non-concurrent requests\"></a>Non-concurrent requests</h2><p>In the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. </p>\n<p>The get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the <a href=\"https://nodejs.org/api/process.html#process_process_hrtime_time\" target=\"_blank\" rel=\"noopener\">hrtime()</a> method from the process package.</p>\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\n<p>Due to the get function being called straight with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\" target=\"_blank\" rel=\"noopener\">await</a> keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.</p>\n<p><img src=\"/blog/blog-images/non-concurrent.gif\" alt=\"Non concurrent\"></p>\n<h2 id=\"Concurrent-requests\"><a href=\"#Concurrent-requests\" class=\"headerlink\" title=\"Concurrent requests\"></a>Concurrent requests</h2><p>Since none of the results depend on each other, we can simply execute all the requests at once. </p>\n<p>With just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request’s execution time from 10s to 3s.</p>\n<p>In the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. </p>\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\n<p>In the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.</p>\n<p><img src=\"/blog/blog-images/concurrent.gif\" alt=\"Concurrent requests\"></p>\n<p>The Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></li>\n<li><a href=\"https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/\" target=\"_blank\" rel=\"noopener\">Concurrency vs. Parallelism, Lokesh Gupta</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and the event loop</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>What is concurrency anyway? You’ve probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Computer_science\" target=\"_blank\" rel=\"noopener\">computer science</a>, <strong>concurrency</strong> is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.</p>\n</blockquote>\n<p>With this in mind, let’s go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.</p>\n<h2 id=\"Helper-function\"><a href=\"#Helper-function\" class=\"headerlink\" title=\"Helper function\"></a>Helper function</h2><p>In the script below, I implement a small helper function that uses <a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios</a> to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.</p>\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n<h2 id=\"Non-concurrent-requests\"><a href=\"#Non-concurrent-requests\" class=\"headerlink\" title=\"Non-concurrent requests\"></a>Non-concurrent requests</h2><p>In the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. </p>\n<p>The get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the <a href=\"https://nodejs.org/api/process.html#process_process_hrtime_time\" target=\"_blank\" rel=\"noopener\">hrtime()</a> method from the process package.</p>\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\n<p>Due to the get function being called straight with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\" target=\"_blank\" rel=\"noopener\">await</a> keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.</p>\n<p><img src=\"/blog/blog-images/non-concurrent.gif\" alt=\"Non concurrent\"></p>\n<h2 id=\"Concurrent-requests\"><a href=\"#Concurrent-requests\" class=\"headerlink\" title=\"Concurrent requests\"></a>Concurrent requests</h2><p>Since none of the results depend on each other, we can simply execute all the requests at once. </p>\n<p>With just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request’s execution time from 10s to 3s.</p>\n<p>In the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. </p>\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\n<p>In the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.</p>\n<p><img src=\"/blog/blog-images/concurrent.gif\" alt=\"Concurrent requests\"></p>\n<p>The Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></li>\n<li><a href=\"https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/\" target=\"_blank\" rel=\"noopener\">Concurrency vs. Parallelism, Lokesh Gupta</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and the event loop</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck4wq4cbp0000d5121lc81gvp","tag_id":"ck4wq4cbx0002d5121oe10znk","_id":"ck4wq4cc20004d51295ai5wpw"},{"post_id":"ck4wq4cbv0001d512djh065pu","tag_id":"ck4wq4cc10003d51218w7ax3g","_id":"ck4wq4cc30005d5123m4x8jud"}],"Tag":[{"name":"urlfy, shortening, idea, projects","_id":"ck4wq4cbx0002d5121oe10znk"},{"name":"javascript, nodejs, asynchronous, programming, promises, concurrency","_id":"ck4wq4cc10003d51218w7ax3g"}]}}