{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/firminocustomtheme/source/css/main.sass","path":"css/main.sass","modified":1,"renderable":1},{"_id":"themes/firminocustomtheme/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/img/firminochangani.png","path":"img/firminochangani.png","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/concurrent.gif","path":"blog-images/concurrent.gif","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/non-concurrent.gif","path":"blog-images/non-concurrent.gif","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/urlfy.xyz.png","path":"blog-images/urlfy.xyz.png","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/Executing-concurrent-HTTP-requests.png","path":"blog-images/Executing-concurrent-HTTP-requests.png","modified":0,"renderable":1},{"_id":"themes/firminocustomtheme/source/blog-images/mongodb-mongoose-minimal-offset-based-pagination.png","path":"blog-images/mongodb-mongoose-minimal-offset-based-pagination.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/firminocustomtheme/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1577806895866},{"_id":"themes/firminocustomtheme/README.md","hash":"4cd14dd17c22ce6ae75287ae30050d062a48e836","modified":1577806895867},{"_id":"themes/firminocustomtheme/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1577806895868},{"_id":"themes/firminocustomtheme/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1577806895872},{"_id":"source/_posts/MongoDB-Mongoose-minimap-offset-based-pagination.md","hash":"be7bf6820f39c264f9ea04ce7b60defd7d6a6d09","modified":1579044756813},{"_id":"source/_posts/Executing-concurrent-HTTP-requests.md","hash":"d8b3488aa72aced7dc72291360f007cd5f84a48d","modified":1577808477045},{"_id":"source/_posts/Building-URLFY-The-idea.md","hash":"c631299f03ca0cfe19a91808b0a1b7ae1e2879ce","modified":1577969742529},{"_id":"themes/firminocustomtheme/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1577806895868},{"_id":"themes/firminocustomtheme/languages/pt.yml","hash":"10ac1e67cd67db2f2ba8caf82fdd5e1042bac037","modified":1577806895869},{"_id":"themes/firminocustomtheme/layout/index.pug","hash":"728538f21235b543998ee4a12c3ced6f7cd96e29","modified":1579045443998},{"_id":"themes/firminocustomtheme/layout/post.pug","hash":"14b2bcdeca3e12c3ea995d49f98a29c005e8ad65","modified":1579038587128},{"_id":"themes/firminocustomtheme/layout/_partial/_disqus.pug","hash":"b1f4cbff6e02fdf580da316cd2ac3fd24fdee659","modified":1577806895870},{"_id":"themes/firminocustomtheme/layout/_partial/_footer.pug","hash":"302ac65d5f4c27b8afb68738fbf7d3fce06a95ce","modified":1579038784031},{"_id":"themes/firminocustomtheme/layout/_partial/_header.pug","hash":"993f46a8302c2594e7f06d34ff6822be99ee177d","modified":1577806895871},{"_id":"themes/firminocustomtheme/source/css/main.sass","hash":"e94049423b835c2185cfc2702a959402df841090","modified":1579045757050},{"_id":"themes/firminocustomtheme/source/img/favicon.png","hash":"24a69506b188a8519fb758abb3cc7a653afcb021","modified":1579038533245},{"_id":"themes/firminocustomtheme/source/img/firminochangani.png","hash":"8dff31c410dcc6ffcb483092fd7d1bc656115fae","modified":1579039053682},{"_id":"themes/firminocustomtheme/source/js/script.js","hash":"93e40b0c061b73399a380c97a777c0d5f09a993f","modified":1577806895878},{"_id":"themes/firminocustomtheme/source/blog-images/concurrent.gif","hash":"e3858c8db8c29eb9ac35a535a9f3230cc29d95ac","modified":1577806895873},{"_id":"themes/firminocustomtheme/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577806895874},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577806895874},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577806895876},{"_id":"themes/firminocustomtheme/source/css/partials/_variables.sass","hash":"102baf696dedf3327eb0ea0ca980a3f0e79c482c","modified":1577806895877},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577806895875},{"_id":"themes/firminocustomtheme/source/blog-images/non-concurrent.gif","hash":"2eaabdc42285d206316253a093efcf9afb0ce3dc","modified":1577806895873},{"_id":"themes/firminocustomtheme/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1577806895875},{"_id":"themes/firminocustomtheme/source/blog-images/urlfy.xyz.png","hash":"24195ec06229d3d9bc3a0ec3739e55dda7bbc03a","modified":1577969153302},{"_id":"themes/firminocustomtheme/source/blog-images/Executing-concurrent-HTTP-requests.png","hash":"aa9bd5c790d567d9ccd9fe07f9c624c463246ee7","modified":1577808394817},{"_id":"themes/firminocustomtheme/source/blog-images/mongodb-mongoose-minimal-offset-based-pagination.png","hash":"4198bc511091ff3eac6dc5cad9d87d45fda7f1ae","modified":1579044344430},{"_id":"public/2020/01/14/MongoDB-Mongoose-minimap-offset-based-pagination/index.html","hash":"37038d5700e9dd630ae3ff906164e4dad52f949b","modified":1579045816576},{"_id":"public/2020/01/02/Building-URLFY-The-idea/index.html","hash":"32d8e5329d54afdb5c6b6d65e69017e7714f70fa","modified":1579045816576},{"_id":"public/2019/12/22/Executing-concurrent-HTTP-requests/index.html","hash":"b50b50ffeaed3a436515ff6ceba9ccabd39b1fde","modified":1579045816576},{"_id":"public/archives/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/archives/2019/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/archives/2019/12/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/archives/2020/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/archives/2020/01/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/tags/mongodb-express-nodejs-pagination-offset/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/tags/javascript-nodejs-asynchronous-programming-promises-concurrency/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/tags/urlfy-shortening-idea-projects/index.html","hash":"3303ef2452c87d27aa157f97e34618870877d474","modified":1579045816576},{"_id":"public/img/favicon.png","hash":"24a69506b188a8519fb758abb3cc7a653afcb021","modified":1579045816576},{"_id":"public/img/firminochangani.png","hash":"8dff31c410dcc6ffcb483092fd7d1bc656115fae","modified":1579045816576},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1579045816576},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1579045816576},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1579045816576},{"_id":"public/blog-images/concurrent.gif","hash":"e3858c8db8c29eb9ac35a535a9f3230cc29d95ac","modified":1579045816576},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1579045816576},{"_id":"public/css/main.css","hash":"688ce512883f5d7f5c9756f3e399ea331e3e1361","modified":1579045816576},{"_id":"public/js/script.js","hash":"93e40b0c061b73399a380c97a777c0d5f09a993f","modified":1579045816576},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1579045816576},{"_id":"public/blog-images/non-concurrent.gif","hash":"2eaabdc42285d206316253a093efcf9afb0ce3dc","modified":1579045816576},{"_id":"public/blog-images/urlfy.xyz.png","hash":"24195ec06229d3d9bc3a0ec3739e55dda7bbc03a","modified":1579045816576},{"_id":"public/blog-images/Executing-concurrent-HTTP-requests.png","hash":"aa9bd5c790d567d9ccd9fe07f9c624c463246ee7","modified":1579045816576},{"_id":"public/blog-images/mongodb-mongoose-minimal-offset-based-pagination.png","hash":"4198bc511091ff3eac6dc5cad9d87d45fda7f1ae","modified":1579045816576}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"MongoDB/Mongoose minimap offset-based pagination","date":"2020-01-14T23:29:53.000Z","cover":"blog-images/mongodb-mongoose-minimal-offset-based-pagination.png","_content":"\nIt's minimal because I don't implement the following features in the pagination:\n\n- Current page\n- Previous page\n- Next page\n- Total items\n\nLet's assume you have a collection called cars, and you don't want to return all the items at once, for the sake of your frontend application or API consumers. A quick way to implement simple and yet functional pagination is:\n\n- To limit the query results. It's a good idea to set a default limit value.\n- Enabling API consumers to set the results limit when performing a request, using query variables.\n- Enabling API consumers to set the page or offset value when performing a query, using query variables.\n- Ensuring that both query variables are integers, offset is equal or greater than 0, and the limit variable is equal or greater than 1 and less than the default limit.\n\nTo materialize what I just described, I will be using MongoDB with Mongoose, and Nodejs with Express: \n\n<script src=\"https://gist.github.com/flowck/c4d18846b1b23c3e9522aadf0ba22f6c.js\"></script>\n\nIn the code above, I:\n\n* Set the default results limit value to 50.\n* I assign the query variables `limit` and `offset` values as an integer in their respective constants, if they were defined or, if they were not defined, the default values 50 and 0 are used.\n* I validate both parameters. As I told in the comments, I usually do this type of validations in the middleware level using [express-validation](https://www.npmjs.com/package/express-validation) and [joi](https://www.npmjs.com/package/joi). \n* Then I finally perform the query on the `CarsModel` using the `.skip()` and `.limit()` methods. \n\n## What's the purpose of .skip()?\n\nFrom MongoDB documentation: \n\n> Skips over the specified number of [documents](https://docs.mongodb.com/manual/reference/glossary/#term-document) that pass into the stage and passes the remaining documents to the next stage in the [pipeline](https://docs.mongodb.com/manual/reference/glossary/#term-pipeline).\n\nIn more simple words, when you specify `Model.find().limit(50).skip(1)` while performing a query,MongoDB ignores the first 50 results and only returns the results starting from 51 to 101.\n\n## References\n\n* https://mongoosejs.com/docs/api.html#query_Query-skip\n* https://docs.mongodb.com/manual/reference/operator/aggregation/skip/\n\n* Post cover author: https://urlfy.xyz/AAAF2Jno","source":"_posts/MongoDB-Mongoose-minimap-offset-based-pagination.md","raw":"---\ntitle: MongoDB/Mongoose minimap offset-based pagination\ndate: 2020-01-14 23:29:53\ntags: mongodb, express, nodejs, pagination, offset\ncover: \"blog-images/mongodb-mongoose-minimal-offset-based-pagination.png\"\n---\n\nIt's minimal because I don't implement the following features in the pagination:\n\n- Current page\n- Previous page\n- Next page\n- Total items\n\nLet's assume you have a collection called cars, and you don't want to return all the items at once, for the sake of your frontend application or API consumers. A quick way to implement simple and yet functional pagination is:\n\n- To limit the query results. It's a good idea to set a default limit value.\n- Enabling API consumers to set the results limit when performing a request, using query variables.\n- Enabling API consumers to set the page or offset value when performing a query, using query variables.\n- Ensuring that both query variables are integers, offset is equal or greater than 0, and the limit variable is equal or greater than 1 and less than the default limit.\n\nTo materialize what I just described, I will be using MongoDB with Mongoose, and Nodejs with Express: \n\n<script src=\"https://gist.github.com/flowck/c4d18846b1b23c3e9522aadf0ba22f6c.js\"></script>\n\nIn the code above, I:\n\n* Set the default results limit value to 50.\n* I assign the query variables `limit` and `offset` values as an integer in their respective constants, if they were defined or, if they were not defined, the default values 50 and 0 are used.\n* I validate both parameters. As I told in the comments, I usually do this type of validations in the middleware level using [express-validation](https://www.npmjs.com/package/express-validation) and [joi](https://www.npmjs.com/package/joi). \n* Then I finally perform the query on the `CarsModel` using the `.skip()` and `.limit()` methods. \n\n## What's the purpose of .skip()?\n\nFrom MongoDB documentation: \n\n> Skips over the specified number of [documents](https://docs.mongodb.com/manual/reference/glossary/#term-document) that pass into the stage and passes the remaining documents to the next stage in the [pipeline](https://docs.mongodb.com/manual/reference/glossary/#term-pipeline).\n\nIn more simple words, when you specify `Model.find().limit(50).skip(1)` while performing a query,MongoDB ignores the first 50 results and only returns the results starting from 51 to 101.\n\n## References\n\n* https://mongoosejs.com/docs/api.html#query_Query-skip\n* https://docs.mongodb.com/manual/reference/operator/aggregation/skip/\n\n* Post cover author: https://urlfy.xyz/AAAF2Jno","slug":"MongoDB-Mongoose-minimap-offset-based-pagination","published":1,"updated":"2020-01-14T23:34:14.377Z","_id":"ck5eihj7q00004i123igjbr54","comments":1,"layout":"post","photos":[],"link":"","content":"<p>It’s minimal because I don’t implement the following features in the pagination:</p>\n<ul>\n<li>Current page</li>\n<li>Previous page</li>\n<li>Next page</li>\n<li>Total items</li>\n</ul>\n<p>Let’s assume you have a collection called cars, and you don’t want to return all the items at once, for the sake of your frontend application or API consumers. A quick way to implement simple and yet functional pagination is:</p>\n<ul>\n<li>To limit the query results. It’s a good idea to set a default limit value.</li>\n<li>Enabling API consumers to set the results limit when performing a request, using query variables.</li>\n<li>Enabling API consumers to set the page or offset value when performing a query, using query variables.</li>\n<li>Ensuring that both query variables are integers, offset is equal or greater than 0, and the limit variable is equal or greater than 1 and less than the default limit.</li>\n</ul>\n<p>To materialize what I just described, I will be using MongoDB with Mongoose, and Nodejs with Express: </p>\n<script src=\"https://gist.github.com/flowck/c4d18846b1b23c3e9522aadf0ba22f6c.js\"></script>\n\n<p>In the code above, I:</p>\n<ul>\n<li>Set the default results limit value to 50.</li>\n<li>I assign the query variables <code>limit</code> and <code>offset</code> values as an integer in their respective constants, if they were defined or, if they were not defined, the default values 50 and 0 are used.</li>\n<li>I validate both parameters. As I told in the comments, I usually do this type of validations in the middleware level using <a href=\"https://www.npmjs.com/package/express-validation\" target=\"_blank\" rel=\"noopener\">express-validation</a> and <a href=\"https://www.npmjs.com/package/joi\" target=\"_blank\" rel=\"noopener\">joi</a>. </li>\n<li>Then I finally perform the query on the <code>CarsModel</code> using the <code>.skip()</code> and <code>.limit()</code> methods. </li>\n</ul>\n<h2 id=\"What’s-the-purpose-of-skip\"><a href=\"#What’s-the-purpose-of-skip\" class=\"headerlink\" title=\"What’s the purpose of .skip()?\"></a>What’s the purpose of .skip()?</h2><p>From MongoDB documentation: </p>\n<blockquote>\n<p>Skips over the specified number of <a href=\"https://docs.mongodb.com/manual/reference/glossary/#term-document\" target=\"_blank\" rel=\"noopener\">documents</a> that pass into the stage and passes the remaining documents to the next stage in the <a href=\"https://docs.mongodb.com/manual/reference/glossary/#term-pipeline\" target=\"_blank\" rel=\"noopener\">pipeline</a>.</p>\n</blockquote>\n<p>In more simple words, when you specify <code>Model.find().limit(50).skip(1)</code> while performing a query,MongoDB ignores the first 50 results and only returns the results starting from 51 to 101.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><p><a href=\"https://mongoosejs.com/docs/api.html#query_Query-skip\" target=\"_blank\" rel=\"noopener\">https://mongoosejs.com/docs/api.html#query_Query-skip</a></p>\n</li>\n<li><p><a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/skip/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/reference/operator/aggregation/skip/</a></p>\n</li>\n<li><p>Post cover author: <a href=\"https://urlfy.xyz/AAAF2Jno\" target=\"_blank\" rel=\"noopener\">https://urlfy.xyz/AAAF2Jno</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>It’s minimal because I don’t implement the following features in the pagination:</p>\n<ul>\n<li>Current page</li>\n<li>Previous page</li>\n<li>Next page</li>\n<li>Total items</li>\n</ul>\n<p>Let’s assume you have a collection called cars, and you don’t want to return all the items at once, for the sake of your frontend application or API consumers. A quick way to implement simple and yet functional pagination is:</p>\n<ul>\n<li>To limit the query results. It’s a good idea to set a default limit value.</li>\n<li>Enabling API consumers to set the results limit when performing a request, using query variables.</li>\n<li>Enabling API consumers to set the page or offset value when performing a query, using query variables.</li>\n<li>Ensuring that both query variables are integers, offset is equal or greater than 0, and the limit variable is equal or greater than 1 and less than the default limit.</li>\n</ul>\n<p>To materialize what I just described, I will be using MongoDB with Mongoose, and Nodejs with Express: </p>\n<script src=\"https://gist.github.com/flowck/c4d18846b1b23c3e9522aadf0ba22f6c.js\"></script>\n\n<p>In the code above, I:</p>\n<ul>\n<li>Set the default results limit value to 50.</li>\n<li>I assign the query variables <code>limit</code> and <code>offset</code> values as an integer in their respective constants, if they were defined or, if they were not defined, the default values 50 and 0 are used.</li>\n<li>I validate both parameters. As I told in the comments, I usually do this type of validations in the middleware level using <a href=\"https://www.npmjs.com/package/express-validation\" target=\"_blank\" rel=\"noopener\">express-validation</a> and <a href=\"https://www.npmjs.com/package/joi\" target=\"_blank\" rel=\"noopener\">joi</a>. </li>\n<li>Then I finally perform the query on the <code>CarsModel</code> using the <code>.skip()</code> and <code>.limit()</code> methods. </li>\n</ul>\n<h2 id=\"What’s-the-purpose-of-skip\"><a href=\"#What’s-the-purpose-of-skip\" class=\"headerlink\" title=\"What’s the purpose of .skip()?\"></a>What’s the purpose of .skip()?</h2><p>From MongoDB documentation: </p>\n<blockquote>\n<p>Skips over the specified number of <a href=\"https://docs.mongodb.com/manual/reference/glossary/#term-document\" target=\"_blank\" rel=\"noopener\">documents</a> that pass into the stage and passes the remaining documents to the next stage in the <a href=\"https://docs.mongodb.com/manual/reference/glossary/#term-pipeline\" target=\"_blank\" rel=\"noopener\">pipeline</a>.</p>\n</blockquote>\n<p>In more simple words, when you specify <code>Model.find().limit(50).skip(1)</code> while performing a query,MongoDB ignores the first 50 results and only returns the results starting from 51 to 101.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><p><a href=\"https://mongoosejs.com/docs/api.html#query_Query-skip\" target=\"_blank\" rel=\"noopener\">https://mongoosejs.com/docs/api.html#query_Query-skip</a></p>\n</li>\n<li><p><a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/skip/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/reference/operator/aggregation/skip/</a></p>\n</li>\n<li><p>Post cover author: <a href=\"https://urlfy.xyz/AAAF2Jno\" target=\"_blank\" rel=\"noopener\">https://urlfy.xyz/AAAF2Jno</a></p>\n</li>\n</ul>\n"},{"title":"Executing concurrent HTTP requests","date":"2019-12-22T21:09:57.000Z","description":"Read more about executing concurrent HTTP requests using Promises and async/await.","cover":"blog-images/Executing-concurrent-HTTP-requests.png","_content":"\nWhat is concurrency anyway? You've probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:\n\n>In [computer science](https://en.wikipedia.org/wiki/Computer_science), **concurrency** is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.\n\n\nWith this in mind, let's go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.\n\n## Helper function\n\nIn the script below, I implement a small helper function that uses [axios](https://www.npmjs.com/package/axios) to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.\n\n\n\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n## Non-concurrent requests\n\nIn the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. \n\nThe get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the [hrtime()](https://nodejs.org/api/process.html#process_process_hrtime_time) method from the process package.\n\n\n\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\nDue to the get function being called straight with the [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.\n\n\n\n![Non concurrent](/blog/blog-images/non-concurrent.gif)\n\n\n\n## Concurrent requests\n\nSince none of the results depend on each other, we can simply execute all the requests at once. \n\nWith just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request's execution time from 10s to 3s.\n\nIn the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. \n\n\n\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\nIn the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.\n\n\n\n![Concurrent requests](/blog/blog-images/concurrent.gif)\n\n\n\nThe Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.\n\n \n\n## References\n\n* [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n* [Concurrency vs. Parallelism, Lokesh Gupta](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/)\n* [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)","source":"_posts/Executing-concurrent-HTTP-requests.md","raw":"---\ntitle: Executing concurrent HTTP requests\ndate: 2019-12-22 21:09:57\ntags: javascript, nodejs, asynchronous, programming, promises, concurrency\ndescription: Read more about executing concurrent HTTP requests using Promises and async/await.\ncover: \"blog-images/Executing-concurrent-HTTP-requests.png\"\n---\n\nWhat is concurrency anyway? You've probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:\n\n>In [computer science](https://en.wikipedia.org/wiki/Computer_science), **concurrency** is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.\n\n\nWith this in mind, let's go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.\n\n## Helper function\n\nIn the script below, I implement a small helper function that uses [axios](https://www.npmjs.com/package/axios) to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.\n\n\n\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n## Non-concurrent requests\n\nIn the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. \n\nThe get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the [hrtime()](https://nodejs.org/api/process.html#process_process_hrtime_time) method from the process package.\n\n\n\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\nDue to the get function being called straight with the [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.\n\n\n\n![Non concurrent](/blog/blog-images/non-concurrent.gif)\n\n\n\n## Concurrent requests\n\nSince none of the results depend on each other, we can simply execute all the requests at once. \n\nWith just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request's execution time from 10s to 3s.\n\nIn the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. \n\n\n\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\nIn the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.\n\n\n\n![Concurrent requests](/blog/blog-images/concurrent.gif)\n\n\n\nThe Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.\n\n \n\n## References\n\n* [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n* [Concurrency vs. Parallelism, Lokesh Gupta](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/)\n* [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)","slug":"Executing-concurrent-HTTP-requests","published":1,"updated":"2019-12-31T16:07:57.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5eihj7x00014i122r0kd1og","content":"<p>What is concurrency anyway? You’ve probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Computer_science\" target=\"_blank\" rel=\"noopener\">computer science</a>, <strong>concurrency</strong> is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.</p>\n</blockquote>\n<p>With this in mind, let’s go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.</p>\n<h2 id=\"Helper-function\"><a href=\"#Helper-function\" class=\"headerlink\" title=\"Helper function\"></a>Helper function</h2><p>In the script below, I implement a small helper function that uses <a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios</a> to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.</p>\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n<h2 id=\"Non-concurrent-requests\"><a href=\"#Non-concurrent-requests\" class=\"headerlink\" title=\"Non-concurrent requests\"></a>Non-concurrent requests</h2><p>In the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. </p>\n<p>The get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the <a href=\"https://nodejs.org/api/process.html#process_process_hrtime_time\" target=\"_blank\" rel=\"noopener\">hrtime()</a> method from the process package.</p>\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\n<p>Due to the get function being called straight with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\" target=\"_blank\" rel=\"noopener\">await</a> keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.</p>\n<p><img src=\"/blog/blog-images/non-concurrent.gif\" alt=\"Non concurrent\"></p>\n<h2 id=\"Concurrent-requests\"><a href=\"#Concurrent-requests\" class=\"headerlink\" title=\"Concurrent requests\"></a>Concurrent requests</h2><p>Since none of the results depend on each other, we can simply execute all the requests at once. </p>\n<p>With just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request’s execution time from 10s to 3s.</p>\n<p>In the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. </p>\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\n<p>In the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.</p>\n<p><img src=\"/blog/blog-images/concurrent.gif\" alt=\"Concurrent requests\"></p>\n<p>The Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></li>\n<li><a href=\"https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/\" target=\"_blank\" rel=\"noopener\">Concurrency vs. Parallelism, Lokesh Gupta</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and the event loop</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>What is concurrency anyway? You’ve probably known or heard this term somewhere, so before going into specific implementation details, let me explain or refresh you about the concurrent part using Wikipedia:</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Computer_science\" target=\"_blank\" rel=\"noopener\">computer science</a>, <strong>concurrency</strong> is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in the partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can significantly improve the overall speed of the execution in multi-processor and multi-core systems.</p>\n</blockquote>\n<p>With this in mind, let’s go straight to a use case where we need to write an application that executes multiple HTTP GET requests to an endpoint, stores each result in an array, and then logs the result into the terminal.</p>\n<h2 id=\"Helper-function\"><a href=\"#Helper-function\" class=\"headerlink\" title=\"Helper function\"></a>Helper function</h2><p>In the script below, I implement a small helper function that uses <a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios</a> to execute HTTP requests, at the same time these functions also logs in the terminal the time spent executing the HTTP request.</p>\n<script src=\"https://gist.github.com/flowck/9e422fe9ac958f42bfbaeee65dbcdc77.js\"></script>\n\n\n\n<h2 id=\"Non-concurrent-requests\"><a href=\"#Non-concurrent-requests\" class=\"headerlink\" title=\"Non-concurrent requests\"></a>Non-concurrent requests</h2><p>In the script below, where I manage to implement a function that takes n as a parameter, representing the number of requests to be executed. </p>\n<p>The get function returns a promise object, so I am using the await keyword inside on an async. On this same function, I am also logging the overall execution time using the <a href=\"https://nodejs.org/api/process.html#process_process_hrtime_time\" target=\"_blank\" rel=\"noopener\">hrtime()</a> method from the process package.</p>\n<script src=\"https://gist.github.com/flowck/6dcedb5e2fc5bc2153752c8fa6b46403.js\"></script>\n\n\n\n<p>Due to the get function being called straight with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\" target=\"_blank\" rel=\"noopener\">await</a> keyword, the for statement only iterates next when the promise is resolved. In the image, bellow can see that each request is executed one after another.</p>\n<p><img src=\"/blog/blog-images/non-concurrent.gif\" alt=\"Non concurrent\"></p>\n<h2 id=\"Concurrent-requests\"><a href=\"#Concurrent-requests\" class=\"headerlink\" title=\"Concurrent requests\"></a>Concurrent requests</h2><p>Since none of the results depend on each other, we can simply execute all the requests at once. </p>\n<p>With just a few changes in the script above, it was possible to achieve a good level of concurrency and reduce the overall request’s execution time from 10s to 3s.</p>\n<p>In the script below, I wrap all the unfulfilled request promises in an array and then I use Promise.all all of the 50 promises. </p>\n<script src=\"https://gist.github.com/flowck/fd04fb17ef771a808baa662044c17e1b.js\"></script>\n\n\n\n<p>In the result bellow you can that the script took 3s seconds to execute 50 requests instead of 10 seconds as in the first script.</p>\n<p><img src=\"/blog/blog-images/concurrent.gif\" alt=\"Concurrent requests\"></p>\n<p>The Promise.all(results) method, returns a single promise when all the promises stored on results are fulfilled.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></li>\n<li><a href=\"https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/\" target=\"_blank\" rel=\"noopener\">Concurrency vs. Parallelism, Lokesh Gupta</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and the event loop</a></li>\n</ul>\n"},{"title":"Building URLFY - The idea","date":"2020-01-02T12:21:08.000Z","description":"On this blog post I explain how I came out with the idea of building a shortening service","cover":"blog-images/urlfy.xyz.png","_content":"\nI was studying system design during the Christmas holidays of 2019, and while reading a blog [post](https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444), I found a challenge that quickly caught my attention: \n\n>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?\n\nThat sounded like a very simple web application, but then, in the same blog post, a few questions where also made:\n\n>How to generate a unique ID for each URL?\n>How would you generate unique IDs at scale (thousands of URL shortening >requests coming every second)?\n>How would your service handle redirects?\n>How would you support custom short URLs?\n>How to delete expired URLs etc?\n>How to track click stats?\n\nAfter reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.\n\n![Urlfy](/blog/blog-images/urlfy.xyz.png)\n\nLong story short, I ended building something which a call [Ulrfy.xyz](https://app.urlfy.xyz), a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello [board](https://trello.com/b/YZDrArI2/urlfyxyz) where I manage my backlog is open for the public.\n\nThis was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.","source":"_posts/Building-URLFY-The-idea.md","raw":"---\ntitle: Building URLFY - The idea\ndate: 2020-01-02 12:21:08\ntags: urlfy, shortening, idea, projects\ndescription: On this blog post I explain how I came out with the idea of building a shortening service\ncover: \"blog-images/urlfy.xyz.png\"\n---\n\nI was studying system design during the Christmas holidays of 2019, and while reading a blog [post](https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444), I found a challenge that quickly caught my attention: \n\n>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?\n\nThat sounded like a very simple web application, but then, in the same blog post, a few questions where also made:\n\n>How to generate a unique ID for each URL?\n>How would you generate unique IDs at scale (thousands of URL shortening >requests coming every second)?\n>How would your service handle redirects?\n>How would you support custom short URLs?\n>How to delete expired URLs etc?\n>How to track click stats?\n\nAfter reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.\n\n![Urlfy](/blog/blog-images/urlfy.xyz.png)\n\nLong story short, I ended building something which a call [Ulrfy.xyz](https://app.urlfy.xyz), a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello [board](https://trello.com/b/YZDrArI2/urlfyxyz) where I manage my backlog is open for the public.\n\nThis was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.","slug":"Building-URLFY-The-idea","published":1,"updated":"2020-01-02T12:55:42.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5eihj8100034i122ni7g18j","content":"<p>I was studying system design during the Christmas holidays of 2019, and while reading a blog <a href=\"https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444\" target=\"_blank\" rel=\"noopener\">post</a>, I found a challenge that quickly caught my attention: </p>\n<blockquote>\n<p>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?</p>\n</blockquote>\n<p>That sounded like a very simple web application, but then, in the same blog post, a few questions where also made:</p>\n<blockquote>\n<p>How to generate a unique ID for each URL?<br>How would you generate unique IDs at scale (thousands of URL shortening &gt;requests coming every second)?<br>How would your service handle redirects?<br>How would you support custom short URLs?<br>How to delete expired URLs etc?<br>How to track click stats?</p>\n</blockquote>\n<p>After reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.</p>\n<p><img src=\"/blog/blog-images/urlfy.xyz.png\" alt=\"Urlfy\"></p>\n<p>Long story short, I ended building something which a call <a href=\"https://app.urlfy.xyz\" target=\"_blank\" rel=\"noopener\">Ulrfy.xyz</a>, a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello <a href=\"https://trello.com/b/YZDrArI2/urlfyxyz\" target=\"_blank\" rel=\"noopener\">board</a> where I manage my backlog is open for the public.</p>\n<p>This was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>I was studying system design during the Christmas holidays of 2019, and while reading a blog <a href=\"https://hackernoon.com/top-10-system-design-interview-questions-for-software-engineers-8561290f0444\" target=\"_blank\" rel=\"noopener\">post</a>, I found a challenge that quickly caught my attention: </p>\n<blockquote>\n<p>Given a (typically) long URL, how would you design service that would generate a shorter and unique alias for it?</p>\n</blockquote>\n<p>That sounded like a very simple web application, but then, in the same blog post, a few questions where also made:</p>\n<blockquote>\n<p>How to generate a unique ID for each URL?<br>How would you generate unique IDs at scale (thousands of URL shortening &gt;requests coming every second)?<br>How would your service handle redirects?<br>How would you support custom short URLs?<br>How to delete expired URLs etc?<br>How to track click stats?</p>\n</blockquote>\n<p>After reading the questions above, I got excited, because it sounded reasonable enough to be built in a short period, but also very important questions were raised.</p>\n<p><img src=\"/blog/blog-images/urlfy.xyz.png\" alt=\"Urlfy\"></p>\n<p>Long story short, I ended building something which a call <a href=\"https://app.urlfy.xyz\" target=\"_blank\" rel=\"noopener\">Ulrfy.xyz</a>, a URL shortening service. Some of the questions above are yet to implemented in the project, and the Trello <a href=\"https://trello.com/b/YZDrArI2/urlfyxyz\" target=\"_blank\" rel=\"noopener\">board</a> where I manage my backlog is open for the public.</p>\n<p>This was a quick post to explain how and where I got this idea, in the next posts I will explain the implementation technical details.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck5eihj7q00004i123igjbr54","tag_id":"ck5eihj7z00024i12glyef55j","_id":"ck5eihj8500054i12euag6yve"},{"post_id":"ck5eihj7x00014i122r0kd1og","tag_id":"ck5eihj8400044i127ifs8vns","_id":"ck5eihj8600074i120qvjdugg"},{"post_id":"ck5eihj8100034i122ni7g18j","tag_id":"ck5eihj8500064i124r90blm2","_id":"ck5eihj8600084i12flol4cg2"}],"Tag":[{"name":"mongodb, express, nodejs, pagination, offset","_id":"ck5eihj7z00024i12glyef55j"},{"name":"javascript, nodejs, asynchronous, programming, promises, concurrency","_id":"ck5eihj8400044i127ifs8vns"},{"name":"urlfy, shortening, idea, projects","_id":"ck5eihj8500064i124r90blm2"}]}}